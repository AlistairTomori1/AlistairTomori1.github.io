<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matrix Platformer – Deluxe</title>
  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
    canvas { display:block; background:#000; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const letters = "アァイィウエェカガキギクグケゲサザシジスズセゼソゾタダチヂッヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモヤユヨラリルレロワンABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}";
    const fontSize = 20;
    ctx.font = fontSize + 'px monospace';
    let charW = ctx.measureText('M').width;
    let audioCtx = null;
    function ensureAudio() { if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
    function beep(freq=440, dur=0.08, type='square', gain=0.05) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.value = gain; g.gain.setTargetAtTime(0, audioCtx.currentTime+dur, 0.02);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(); osc.stop(audioCtx.currentTime + dur + 0.05);
    }
    const playerFrames = [
    [" O ", "/|\\", "/ \\"],
    [" O ", "/|\\", "/ \\"],
    [" O ", "\\|/", "/ \\"],
    [" O ", "/|\\", " \\ /"]
    ];
    let walkFrameCount = 0;
    const walkFrameDelay = 6;
    const playerWidth  = ctx.measureText('M').width * playerFrames[0][0].length;
    const playerHeight = fontSize * playerFrames[0].length;
    const player = { x: 20, y: canvas.height - playerHeight - 10, vx: 0, vy: 0, onGround: false, frameIndex: 0 };
    const gravity = 0.8;
    const moveSpeed = 6;
    const jumpPower = -15;
    let coyote = 0, COYOTE_MAX = 8;
    let jumpBuffer = 0, JUMP_BUFFER_MAX = 8;
    let jumpHeld = false;
    let focus = 100, FOCUS_MAX = 100;
    let timeScale = 1;
    const ghosts = [];
    const keys = {};
    addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (!audioCtx) ensureAudio();
      if (gameState === 'TITLE' && (e.code === 'Enter' || e.code === 'Space')) startGame();
      if (gameState === 'WIN'   && (e.code === 'Enter' || e.code === 'Space')) restart();
      if (e.code === 'KeyP') togglePause();
      if (isJumpKey(e.code)) { jumpBuffer = JUMP_BUFFER_MAX; jumpHeld = true; }
    });
    addEventListener('keyup', (e) => {
      keys[e.code] = false;
      if (isJumpKey(e.code)) jumpHeld = false;
    });
    function isJumpKey(code){ return code==='ArrowUp'||code==='KeyW'||code==='Space'; }
    const platforms = [
      { x:    0, width: 300, baseY: 0 },
      { x:  300, width: 200, baseY: 0 },
      { x:  600, width: 150, baseY: 0, moveY: { amp: 24, speed: 1.1, phase: 0.0 } },
      { x:  850, width: 180, baseY: 0 },
      { x: 1130, width: 220, baseY: 0, moveX: { amp: 40, speed: 0.8, phase: 0.0 } },
      { x: 1450, width: 200, baseY: 0 },
      { x: 1750, width: 180, baseY: 0, moveY: { amp: 30, speed: 0.9, phase: 1.3 } },
      { x: 2030, width: 150, baseY: 0 },
      { x: 2280, width: 200, baseY: 0 },
      { x: 2580, width: 180, baseY: 0, moveX: { amp: 60, speed: 0.6, phase: 0.7 } },
      { x: 2860, width: 220, baseY: 0 },
      { x: 3180, width: 200, baseY: 0 }
    ];
    platforms.forEach(p => { p.y = 0; p.baseX = p.x; });
    let platformChars = [];
    function initPlatformChars() {
      ctx.font = fontSize + 'px monospace';
      charW = ctx.measureText('M').width;
      platformChars = platforms.map(p => {
        const cols = Math.floor(p.width / charW);
        return Array.from({ length: cols }, () => letters[Math.floor(Math.random()*letters.length)]);
      });
    }
    let cameraOffset = 0;
    const portal = { x: 0, y: 0, w: fontSize, h: fontSize*2 };
    const coins = [
      { platformIndex: 1, collected: false },
      { platformIndex: 3, collected: false },
      { platformIndex: 5, collected: false },
      { platformIndex: 7, collected: false },
      { platformIndex: 9, collected: false },
      { platformIndex: 11, collected: false }
    ];
    let score = 0;
    const coinFrames = ['o','o','•','•'];
    let spinFrame = 0, coinSpinFrameCount = 0;
    const coinSpinDelay = 10;
    const obstacles = [
      { platformIndex: 2, width: 40 },
      { platformIndex: 4, width: 40 },
      { platformIndex: 6, width: 40 },
      { platformIndex: 8, width: 40 }
    ];
    function recalcCoinsSpikesPortal(){
      coins.forEach(c => {
        const p = platforms[c.platformIndex];
        c.x = p.x + (p.width - charW)/2;
        c.y = p.y - fontSize;
      });
      obstacles.forEach(o => { const p = platforms[o.platformIndex]; o.x = p.x + (p.width - o.width)/2; o.y = p.y; });
      const last = platforms[platforms.length-1];
      portal.x = last.x + last.width - 40;
      portal.y = last.y - fontSize;
    }
    let bgColumns;
    let frontTrails=[], midTrails=[], backTrails=[];
    let frontHeads=[],  midHeads=[],  backHeads=[];
    function initBackground() {
      bgColumns = Math.floor(canvas.width / fontSize);
      const mk = () => Array.from({ length: bgColumns }, () => []);
      const hk = () => Array.from({ length: bgColumns }, () => Math.random()*(canvas.height/fontSize));
      frontTrails = mk(); midTrails = mk(); backTrails = mk();
      frontHeads = hk();  midHeads = hk();  backHeads = hk();
    }
    function drawRainLayer(trails, heads, speed, opacity, fadeAlpha, decay) {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.fillStyle = `rgba(0,0,0,${fadeAlpha})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
      ctx.font = fontSize + 'px monospace';
      for (let i=0;i<bgColumns;i++) {
        heads[i] += speed * timeScale;
        if (heads[i] > canvas.height/fontSize + 10) heads[i] = -10;
        const row = Math.floor(heads[i]);
        const last = trails[i][0] ? trails[i][0].y : undefined;
        if (last !== row) trails[i].unshift({ char: letters[Math.floor(Math.random()*letters.length)], y: row });
        if (trails[i].length > Math.floor(canvas.height/fontSize) + 200) trails[i].pop();
        trails[i].forEach((cell, idx) => {
          const y = cell.y * fontSize;
          if (y < -fontSize || y > canvas.height + fontSize) return;
          const bright = Math.max(0.02, opacity - idx*decay);
          ctx.fillStyle = `rgba(0,255,0,${bright})`;
          ctx.fillText(cell.char, i*fontSize, y);
        });
      }
    }
    let gameState = 'TITLE';
    let runStartTime = 0;
    let elapsed = 0;
    function startGame(){
      gameState = 'PLAY';
      runStartTime = performance.now();
      score = 0; focus = 100; timeScale = 1; ghosts.length = 0;
      player.x = 20; player.y = canvas.height - playerHeight - 10; player.vx = 0; player.vy = 0;
      beep(660, 0.08, 'sine', 0.05);
    }
    function restart(){ gameState = 'TITLE'; }
    function togglePause(){ if (gameState==='PLAY') gameState='PAUSE'; else if (gameState==='PAUSE') gameState='PLAY'; }
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.font = fontSize + 'px monospace';
      charW = ctx.measureText('M').width;
      const Y = (off) => canvas.height - off;
      platforms[0].baseY = Y(10);
      platforms[1].baseY = Y(100);
      platforms[2].baseY = Y(180);
      platforms[3].baseY = Y(140);
      platforms[4].baseY = Y(200);
      platforms[5].baseY = Y(120);
      platforms[6].baseY = Y(160);
      platforms[7].baseY = Y(220);
      platforms[8].baseY = Y(140);
      platforms[9].baseY = Y(180);
      platforms[10].baseY = Y(120);
      platforms[11].baseY = Y(200);
      initPlatformChars();
      initBackground();
      recalcCoinsSpikesPortal();
      player.y = canvas.height - playerHeight - 10;
      player.vy = 0;
    }
    window.addEventListener('resize', resize);
    let t = 0;
    function update() {
      if (gameState === 'PAUSE' || gameState === 'TITLE' || gameState === 'WIN') return;
      const wantsSlow = !!(keys['ShiftLeft']||keys['ShiftRight']);
      timeScale = (wantsSlow && focus>0) ? 0.45 : 1;
      if (wantsSlow && focus>0) { focus = Math.max(0, focus - 0.6); }
      else { focus = Math.min(FOCUS_MAX, focus + 0.25); }
      t += 0.06 * timeScale;
      platforms.forEach(p => {
        p.x = p.baseX + (p.moveX ? Math.sin(t * p.moveX.speed + (p.moveX.phase||0)) * p.moveX.amp : 0);
        p.y = p.baseY + (p.moveY ? Math.sin(t * p.moveY.speed + (p.moveY.phase||0)) * p.moveY.amp : 0);
      });
      recalcCoinsSpikesPortal();
      const left  = keys['ArrowLeft']||keys['KeyA'];
      const right = keys['ArrowRight']||keys['KeyD'];
      player.vx = (right? moveSpeed : 0) - (left? moveSpeed : 0);
      if (player.onGround) coyote = COYOTE_MAX; else if (coyote>0) coyote--;
      if (jumpBuffer>0) jumpBuffer--;
      if (jumpBuffer>0 && (player.onGround || coyote>0)) { player.vy = jumpPower; player.onGround=false; jumpBuffer=0; beep(880,0.06,'triangle',0.05); }
      if (!jumpHeld && player.vy < 0) player.vy += 1.2 * timeScale;
      const prevY = player.y;
      player.vy += gravity * timeScale;
      player.x  += player.vx * timeScale;
      player.y  += player.vy * timeScale;
      if (player.onGround && player.vx !== 0) { walkFrameCount++; if (walkFrameCount>=walkFrameDelay){ player.frameIndex=(player.frameIndex+1)%playerFrames.length; walkFrameCount=0; } }
      else { player.frameIndex=0; walkFrameCount=0; }
      player.onGround = false;
      const prevBottom = prevY + playerHeight;
      const currBottom = player.y + playerHeight;
      for (const p of platforms) {
        if (player.x + playerWidth > p.x && player.x < p.x + p.width) {
          if (player.vy > 0 && prevBottom <= p.y && currBottom >= p.y) {
            player.y = p.y - playerHeight; player.vy = 0; player.onGround = true; break;
          }
        }
      }
      const levelWidth = platforms[platforms.length-1].x + platforms[platforms.length-1].width;
      if (player.x < 0) player.x = 0;
      if (player.x + playerWidth > levelWidth) player.x = levelWidth - playerWidth;
      if (player.y > canvas.height + 200) {
        player.x = 20; player.y = canvas.height - playerHeight - 10; player.vy = 0; beep(220,0.12,'sawtooth',0.06);
      }
      coins.forEach(c => {
        if (!c.collected &&
            player.x + playerWidth > c.x && player.x < c.x + fontSize &&
            player.y + playerHeight > c.y && player.y < c.y + fontSize) {
          c.collected = true; score++; beep(1200,0.07,'square',0.05);
          spawnParticles(c.x, c.y, '#FFD700');
        }
      });
      obstacles.forEach(o => {
        if (player.x + playerWidth > o.x && player.x < o.x + o.width && player.y + playerHeight > o.y) {
          player.x = 20; player.y = canvas.height - playerHeight - 10; player.vy = 0; score = Math.max(0, score-1); beep(140,0.1,'square',0.07);
          spawnParticles(player.x, player.y, '#f00');
        }
      });
      if (player.x + playerWidth > portal.x && player.x < portal.x + portal.w &&
          player.y + playerHeight > portal.y && player.y < portal.y + portal.h) {
        gameState = 'WIN'; elapsed = (performance.now() - runStartTime) / 1000; beep(1000,0.1,'triangle',0.07); beep(1400,0.12,'sine',0.06);
      }
      ghosts.push({ x: player.x, y: player.y, frameIndex: player.frameIndex, alpha: 0.25 });
      if (ghosts.length > 8) ghosts.shift();
      const targetX = player.x - canvas.width/3;
      cameraOffset += (targetX - cameraOffset) * 0.1;
      cameraOffset = Math.max(0, Math.min(cameraOffset, levelWidth - canvas.width));
    }
    const particles = [];
    function spawnParticles(x, y, color){
      for (let i=0;i<18;i++) particles.push({ x, y, vx:(Math.random()-0.5)*3, vy:(Math.random()-1.2)*3, life: 30, color });
    }
    function updateParticles(){
      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life--;
        if (p.life <= 0) particles.splice(i,1);
      }
    }
    let frameCount = 0;
    function draw() {
      ctx.save(); ctx.translate(-cameraOffset*0.1, 0); drawRainLayer(backTrails,  backHeads, 0.1, 0.10, 0.20, 0.005); ctx.restore();
      ctx.save(); ctx.translate(-cameraOffset*0.2, 0); drawRainLayer(midTrails,   midHeads,  0.3, 0.20, 0.30, 0.010); ctx.restore();
      ctx.save(); ctx.translate(-cameraOffset*0.4, 0); drawRainLayer(frontTrails,frontHeads,0.6, 0.30, 0.20, 0.010); ctx.restore();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      frameCount++; if (frameCount % 2 === 0) {
        platformChars.forEach((arr, i) => {
          platformChars[i] = arr.map(ch => Math.random()<0.2 ? letters[Math.floor(Math.random()*letters.length)] : ch);
        });
      }
      ctx.save();
      ctx.translate(-cameraOffset, 0);
      ctx.textBaseline = 'bottom';
      ctx.font = fontSize + 'px monospace';
      ctx.fillStyle = '#0f0'; ctx.shadowColor = '#0f0'; ctx.shadowBlur = 6;
      platforms.forEach((p, i) => {
        platformChars[i].forEach((ch, ci) => { ctx.fillText(ch, p.x + ci*charW, p.y); });
      });
      ctx.shadowBlur = 0;
      coinSpinFrameCount++; if (coinSpinFrameCount>=coinSpinDelay){ spinFrame=(spinFrame+1)%coinFrames.length; coinSpinFrameCount=0; }
      ctx.fillStyle = '#FFD700';
      coins.forEach(c => { if (!c.collected) ctx.fillText(coinFrames[spinFrame], c.x, c.y); });
      ctx.fillStyle = '#f00';
      obstacles.forEach(o => { const step = fontSize/1.5; const n = Math.floor(o.width/step); for (let i=0;i<n;i++) ctx.fillText('^', o.x + i*step, o.y); });
      ctx.fillStyle = '#0f0'; ctx.shadowColor = '#0f0'; ctx.shadowBlur = 10;
      ctx.fillText('[=]', portal.x, portal.y);
      ctx.shadowBlur = 0;
      for (let i=0;i<ghosts.length;i++){
        const g = ghosts[i]; const a = (i+1)/ghosts.length * 0.15;
        ctx.fillStyle = `rgba(0,255,0,${a})`;
        const fr = playerFrames[g.frameIndex];
        for (let j=0;j<fr.length;j++) ctx.fillText(fr[j], g.x, g.y + fontSize*(j+1));
      }
      ctx.fillStyle = '#0f0';
      const frame = playerFrames[player.frameIndex];
      const bob = (player.onGround && player.vx !== 0) ? Math.sin((player.frameIndex/playerFrames.length)*Math.PI*2)*2 : 0;
      for (let i=0;i<frame.length;i++) ctx.fillText(frame[i], player.x, player.y + bob + fontSize*(i+1));
      particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillText('.', p.x, p.y); });
      ctx.restore();
      ctx.fillStyle = '#0f0'; ctx.font = '16px monospace'; ctx.textBaseline = 'top';
      ctx.fillText('Score: '+score, 12, 10);
      ctx.fillText('Focus', 12, 32);
      ctx.strokeStyle = 'rgba(0,255,0,0.3)'; ctx.strokeRect(70, 34, 120, 8);
      ctx.fillStyle = 'rgba(0,255,0,0.6)'; ctx.fillRect(70, 34, 120*(focus/FOCUS_MAX), 8);
      if (gameState==='PLAY') { elapsed = (performance.now() - runStartTime)/1000; }
      ctx.fillStyle = '#0f0'; ctx.fillText(`Time: ${elapsed.toFixed(2)}s`, canvas.width - 160, 10);
      if (gameState === 'TITLE' || gameState === 'PAUSE' || gameState === 'WIN') {
        const title = (gameState==='TITLE') ? 'MATRIX RUNNER' : (gameState==='PAUSE' ? 'PAUSED' : 'LEVEL CLEAR');
        ctx.save();
        ctx.shadowBlur = 12; ctx.shadowColor = '#0f0';
        ctx.fillStyle = '#0f0'; ctx.font = '48px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(title, canvas.width/2, canvas.height/2 - 40);
        ctx.shadowBlur = 0; ctx.font = '18px monospace'; ctx.fillStyle = 'rgba(0,255,0,0.8)';
        if (gameState==='TITLE') ctx.fillText('Press Enter to Start   ·   ←/→ move, ↑/Space jump, Shift: Focus, P: Pause', canvas.width/2, canvas.height/2 + 10);
        if (gameState==='PAUSE') ctx.fillText('Press P to Resume', canvas.width/2, canvas.height/2 + 10);
        if (gameState==='WIN')   ctx.fillText(`Time: ${elapsed.toFixed(2)}s   ·   Press Enter to Restart`, canvas.width/2, canvas.height/2 + 10);
        ctx.restore();
      }
    }
    function loop(){
      if (gameState === 'PLAY') { updateParticles(); update(); }
      draw();
      requestAnimationFrame(loop);
    }
    initPlatformChars();
    initBackground();
    resize();
    loop();
    (function testCoinsNotOnSpikes(){
      const spikePlatforms = new Set(obstacles.map(o => o.platformIndex));
      const bad = coins.filter(c => spikePlatforms.has(c.platformIndex));
      console.assert(bad.length === 0, 'Coin on spiked platform!', bad);
    })();
    (function testPlatformChars(){
      console.assert(platformChars.length === platforms.length, 'platformChars length mismatch');
    })();
    (function testPortalPlacement(){
      console.assert(portal.x >= platforms[platforms.length-1].x, 'Portal should be on last platform');
    })();
    (function testPlayerFramesWellFormed(){
      const widths = playerFrames.map(fr => fr.map(s => s.length));
      const w0 = widths[0];
      const allEqual = widths.every(w => w.length===w0.length && w.every((n,i)=>n===w0[i]));
      console.assert(allEqual, 'Player frames rows must be consistent', widths);
      const shapesOk = playerFrames.every(fr => fr.length===3 && fr.every(r => typeof r === 'string'));
      console.assert(shapesOk, 'Each player frame must have 3 string rows');
    })();
  </script>
</body>
</html>
